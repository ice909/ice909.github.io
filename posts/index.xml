<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Ice's Wonder</title><link>https://student-ice.github.io/posts/</link><description>Recent content in Posts on Ice's Wonder</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 22 Sep 2023 18:45:35 +0800</lastBuildDate><atom:link href="https://student-ice.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>操作系统导论</title><link>https://student-ice.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/</link><pubDate>Fri, 22 Sep 2023 18:45:35 +0800</pubDate><guid>https://student-ice.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/</guid><description>操作系统的定义 操作系统（operating system, OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理硬件设备，提高他们的利用率和系统吞吐量，并为用户和应用程序提供一个简单的接口，以便于用户和应用程序使用硬件设备。
操作系统的目标和作用 操作系统的目标 操作系统的主要目标是实现：方便性、有效性、可扩充性、开放性。
操作系统的作用 操作系统的作用是人机交互、资源管理及资源抽象。
推动操作系统发展的主要动力 用户需求是什么 硬件技术的进步 操作系统的发展过程 graph LR 操作系统的发展过程--&amp;gt;B(批处理系统) 操作系统的发展过程--&amp;gt;C(分时操作系统) 操作系统的发展过程--&amp;gt;D(实时操作系统) 操作系统的发展过程--&amp;gt;E(通用操作系统) 操作系统的发展过程--&amp;gt;F(嵌入式操作系统) 操作系统的发展过程--&amp;gt;G(网络操作系统) 操作系统的发展过程--&amp;gt;H(分布式操作系统) 未配置操作系统的计算机系统 还未出现OS的时候，对计算机的全部操作都是由用户采取人工操作的方式进行的
人工操作方式、
缺点： 效率低、缺少交互、用户独占全机、CPU等待人工操作
脱机I/O方式
优点: 减少了CPU的空闲时间、提高了I/O速度
单道批处理系统 单道批处理系统的处理过程
首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业；当该作业处理完成时，又把运行控制权交还给监督程序，再由监督程序把磁带上第二个作业调入内存。计算机系统就这样自动的、一个作业接一个作业地进行处理，直至磁带上的所有作业全部完成，这样便形成了早期的批处理系统。
单道批处理系统的缺点
系统中的资源的不到充分的利用
多道批处理系统 多道程序设计的基本概念
为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期引入了多道程序设计技术，由此形成了多道批处理系统。
多道批处理系统的优点
资源利用率高、系统吞吐量大
多道批处理系统的缺点
平均周转时间长、无交互能力
多道批处理系统需要解决的问题
争用处理机问题 内存分配与保护问题 I/O设备的分配问题 文件的组织与管理问题 作业管理问题 用户与系统的接口问题 分时操作系统 分时操作系统的引入
推动分时操作系统形成和发展的主要动力，是为了满足用户对人机交互的需求。分时系统是在此过程中形成的一种新型操作系统。
用户的需求具体分为以下两个方面
人机交互 共享主机 分时系统实现过程中的关键问题
及时接收 及时处理 分时系统的特征
多路性 独立性 及时性 交互性 实时操作系统 实时操作系统的定义
实时操作系统是指系统能够及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。
实时操作系统的类型
工业控制系统 信息查询系统 多媒体系统 嵌入式系统 实时任务的类型</description></item><item><title>QtQuick的Image组件内存优化</title><link>https://student-ice.github.io/posts/qtquick%E7%9A%84image%E7%BB%84%E4%BB%B6%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</link><pubDate>Tue, 19 Sep 2023 17:09:20 +0800</pubDate><guid>https://student-ice.github.io/posts/qtquick%E7%9A%84image%E7%BB%84%E4%BB%B6%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</guid><description>最近做了一个音乐播放器，使用了QtQuick技术，里面大量使用Image组件显示网络图片，而且图片的尺寸都还很大（大部分尺寸都是1000×1000像素以上）。在运行后发现内存占用很大。仅首页图片加载完内存就占用了500MB,而且我还是多页面叠加显示的，再打开几个新页面，内存占用轻轻松松突破1G。
这肯定是不行的，必须要想办法减少图片的内存占用。然后就去网上搜索了一番，看到了QML的图片加载，内存优化研究这篇文章，里面提到给Image设置souceSize属性可以减少内存占用。 于是我就去查阅了一下官方文档
This property holds the scaled width and height of the full-frame image. Unlike the width and height properties, which scale the painting of the image, this property sets the maximum number of pixels stored for the loaded image so that large images do not use more memory than necessary. For example, this ensures the image in memory is no larger than 1024x1024 pixels, regardless of the Image&amp;#39;s width and height values: Rectangle { width: .</description></item><item><title>浅尝openapi Generator</title><link>https://student-ice.github.io/posts/%E6%B5%85%E5%B0%9Dopenapi-generator/</link><pubDate>Wed, 13 Sep 2023 13:38:13 +0800</pubDate><guid>https://student-ice.github.io/posts/%E6%B5%85%E5%B0%9Dopenapi-generator/</guid><description>最近看到深度之家项目使用openapi-generator生成http api, 供客户端调用，于是很好奇这是什么，经过了一番研究，才发现他其实就是可以根据OpenAPI规范（以前称为Swagger规范）生成各种编程语言的HTTP API客户端、服务器端代码和文档的一个工具。
我正好最近在用Qt开发一个网易云音乐客户端，所以就想着能不能也想深度之家那样用openapi-generator生成HTTP API。 说干就干，首先去看了看官方文档，写的很详细了。使用方法有很多，我这里使用npm安装CLI,直接执行下面的命令，全局安装：
sudo npm install @openapitools/openapi-generator-cli -g 然后根据符合OpenAPI规范的、有效的API文档生成客户端代码:
openapi-generator-cli generate \ -i doc_path \ # 符合OpenAPI规范的API文档(json格式或者yaml格式) -o code_path \ # 要生成的客户端代码路径 -g cpp-qt-client \ # 使用指定的生成器生成代码。 --additional-properties=&amp;#34;optionalProjectFile=false,modelNamePrefix=D,packageName=QtDAPI,cppNamespace=DAPI&amp;#34; # 额外的参数 额外参数的含义可以到官方文档/generators/cpp-qt-client查看。
执行这个命令后就可以在指定的目录下看到生成的代码。
$ tree 3rdparty/client 3rdparty/API ├── README.md └── Config.cmake.in └── CMakeLists.txt └── DClientApi.h └── DClientApi.cpp ......... 然后在代码中就可以调用了，使用方法可以参考生成的README.md</description></item><item><title>Hugo搭建个人博客网站</title><link>https://student-ice.github.io/posts/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</link><pubDate>Fri, 08 Sep 2023 08:57:38 +0800</pubDate><guid>https://student-ice.github.io/posts/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</guid><description>前言 Hugo 是一款基于 Go 语言而实现的静态网站生成器，具有简单易用、高效易扩展、快速部署的特点。 这里先给出 Hugo 的中英文官方文档，方便大家遇到问题时查阅：
Hugo 中文文档 Hugo 英文文档
接下来就来看看，如何利用 Hugo 来搭建一个博客。
1. 安装Hugo 当你打开Hugo的Github Release页面后，你会看到各个版本的Hugo安装包。选择最新的版本是一个明智的选择，因为它通常包含了最新的功能和修复的bug。
在选择版本后，你需要根据你当前的操作系统选择对应的安装包进行下载。Hugo提供了多种操作系统的安装包，包括Windows、macOS和Linux。确保选择与你的操作系统兼容的安装包。
安装完成后，你可以在命令行中输入hugo version来验证Hugo是否成功安装并显示当前安装的版本号。如果成功显示版本号，则说明Hugo已经安装成功。
$ hugo version hugo v0.118.2-da7983ac4b94d97d776d7c2405040de97e95c03d linux/amd64 BuildDate=2023-08-31T11:23:51Z VendorInfo=gohugoio 现在你已经成功安装了Hugo，你可以开始使用它来创建和管理静态网站了。
2. 创建博客目录 初始化网站目录 $ hugo new site blog 初始化之后，得到的，目录结构如下:
$ tree blog blog ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── i18n ├── layouts ├── static └── themes 这里需要注意的是hugo.toml,这个配置文件是用来配置Hugo的一些全局参数的。这个文件默认有以下三个配置:
baseURL = &amp;#39;https://example.org/&amp;#39; languageCode = &amp;#39;en-us&amp;#39; title = &amp;#39;My New Hugo Site&amp;#39; 我不太喜欢toml的语法,所以我把它改成了hugo.</description></item></channel></rss>